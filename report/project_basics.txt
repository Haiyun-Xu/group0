Section 2
2.1.1
    Both the error message and the CR2 register suggest that the address triggering the page fault was 0xc0000008;

2.1.2
    The EIP register suggests that the address of the page faulting instruction is 0x8048757;

2.1.3
    The address 0x8048757 corresponds to instruction "mov 0x24(%esp),%eax" in function "_start", whose disassembled code is as follows:
    08048754 <_start>:
        8048754:	83 ec 1c             	sub    $0x1c,%esp
        8048757:	8b 44 24 24          	mov    0x24(%esp),%eax
        804875b:	89 44 24 04          	mov    %eax,0x4(%esp)
        804875f:	8b 44 24 20          	mov    0x20(%esp),%eax
        8048763:	89 04 24             	mov    %eax,(%esp)
        8048766:	e8 35 f9 ff ff       	call   80480a0 <main>
        804876b:	89 04 24             	mov    %eax,(%esp)
        804876e:	e8 49 1b 00 00       	call   804a2bc <exit>

2.1.4
    The function resides in pintos\src\lib\user\entry.c and is defined as follows:
    void _start (int argc, char *argv[]) {
      exit (main (argc, argv));
    }
    And here's an explanation of the function's assembly instructions:
    08048754 <_start>:                      // @(%ESP) = return address
        8048754:	sub    $0x1c,%esp       // %ESP -= 28, reserves space for the next function's args
        8048757:	mov    0x24(%esp),%eax  // %EAX = @(%ESP+36), temporarily stores the "char *argv[]" in %EAX
        804875b:	mov    %eax,0x4(%esp)   // @(%ESP+4) = %EAX, push the "char *argv[]" onto the stack
        804875f:	mov    0x20(%esp),%eax  // %EAX = @(%ESP+32), temporarily stores the "int argc" in %EAX
        8048763:	mov    %eax,(%esp)      // @(%ESP) = %EAX, push the "int argc" onto the stack
        8048766:	call   80480a0 <main>   // @(%ESP) += 4, decrement %ESP
                                            // @(%ESP) = 0x804876b, push the next instruction address onto the stack as the return address
                                            // jump to <main> @(0x80480a0)
        804876b:	mov    %eax,(%esp)      // @(%ESP) = %EAX, the value returned by callee was in %EAX,
                                            // and is copied onto the stack as the argument to the next function
        804876e:	call   804a2bc <exit>   // @(%ESP) += 4, decrement %ESP
                                            // @(%ESP) = ???, push the next instruction address onto the stack as the return address
                                            // jump to <exit> @(0x804876e)

2.1.5
    The faulting instruction is pushing the "char *argv[]" argument onto the stack for the main() function.

2.2.6
    The current thread executing process_execute() is thread #1 <main>, and its TCB is located at address 0xc0104000. `info threads` shows no other thread at this time, but `dumplist &all_list thread allelem` showed 2 threads (gdb claims thread #0 is invalid but its TCB is indeed dumped):
        Thread #0: 0xc000e000 {tid = 1, status = THREAD_RUNNING, name = "main", '\000' <repeats 11 times>, s tack = 0xc000edec <incomplete sequence \357>, priority = 31, allelem = {prev = 0xc0035910 <all_list>, next = 0xc0104020}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}

        Thread #1: 0xc0104000 {tid = 2, status = THREAD_BLOCKED, name = "idle", '\000' <repeats 11 times>, stack = 0xc0104f34 "", priority = 0, allelem = {prev = 0xc000e020, next = 0xc0035918 <all_list+8>}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}

2.2.7
    The current thread's backtrace is:
        #0  process_execute (file_name=file_name@entry=0xc0007d50 "do-nothing") at ../../userprog/process.c:32
        #1  0xc0020268 in run_task (argv=0xc00357cc <argv+12>) at ../../threads/init.c:288
        #2  0xc0020921 in run_actions (argv=0xc00357cc <argv+12>) at ../../threads/init.c:340
        #3  main () at ../../threads/init.c:133
    Below are the lines corresponding to the function calls that created each stack frame:
        #0  process_wait (process_execute (task)) at ../../threads/init.c:288;
        #1  a->function (argv) at ../../threads/init.c:340;
        #2  run_actions (argv) at ../../threads/init.c:133;
        #3  main (void) at ../../threads/init.c:77;

2.2.8
    The current thread executing start_process() should be thread #2 "do-nothing", and its TCB is located at 0xc010a000, but `info threads` still shows thread #1 as the current thread. The following threads are present in PINTOS at this time:
        Thread #0: 0xc000e000 {tid = 1, status = THREAD_BLOCKED, name = "main", '\000' <repeats 11 times>, stack = 0xc000eeac "\001", priority = 31, allelem = {prev = 0xc0035910 <all_list>, next = 0xc0104020}, elem = {prev = 0xc0037314 <temporary+4>, next = 0xc003731c <temporary+12>}, pagedir = 0x0, magic = 3446325067}

        Thread #1: 0xc0104000 {tid = 2, status = THREAD_BLOCKED, name = "idle", '\000' <repeats 11 times>, stack = 0xc0104f34 "", priority = 0, allelem = {prev = 0xc000e020, next = 0xc010a020}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}

        Thread #2: 0xc010a000 {tid = 3, status = THREAD_RUNNING, name = "do-nothing\000\000\000\000\000", stack = 0xc010afd4 "", priority = 31, allelem = {prev = 0xc0104020, next = 0xc0035918 <all_list+8>}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}

2.2.9
    The thread executing start_process() was created at by the following line of code:
        ```
        tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
        ```
    at ../../userprog/process.c:45;

2.2.10
    The local struct intr_frame if_ has the following values after calling the load() function:
        {
          edi = 0, esi = 0, ebp = 0, esp_dummy = 0, ebx = 0, edx = 0, ecx = 0, eax = 0, gs = 35, fs = 35, es = 35, ds = 35, vec_no = 0, error_code = 0, frame_pointer = 0x0, eip = 0x8048754, cs = 27, eflags = 514, esp = 0xc0000000, ss = 35
        }

2.2.11
    The "mov %0 %%esp;" instruction sets the stack pointer to the bottom of the TCB structure, and the "jmp intr_exit;" instruction jumps to the kernel-side stub function intr_exit(), which discards left-over data on the kernel stack, restores the processor register with states from the TCB, and switches to the user context atomically with the `iret` instruction, thereby starts executing the user program by jumping to its first instruction.

2.2.12
    After executing `iret`, the thread registers have the following values:
        eax            0x0      0
        ecx            0x0      0
        edx            0x0      0
        ebx            0x0      0
        esp            0xc0000000       0xc0000000
        ebp            0x0      0x0
        esi            0x0      0
        edi            0x0      0
        eip            0x8048754        0x8048754
        eflags         0x202    [ IF ]
        cs             0x1b     27
        ss             0x23     35
        ds             0x23     35
        es             0x23     35
        fs             0x23     35
        gs             0x23     35
    which are identical to the content of the interrupt frame if_, meaning that the states in if_ are completely restored to the registers;

2.2.13
    After the page fault, the hardware switches context and jumps to the intrXX_stub() function (XX is the interrupt number), which pushes onto stack the interrupt frame pointer (not the entire intr_frame struct), the error code, and the interrupt vector number. It then jumps to the intr_entry() function - the main entry point of hardware and software interrupts. intr_entry() pushes some more registers onto the stack and sets up the processor states for a call into the main interrupt handler intr_handler(), which then dispatches the thread to various acutal interrupt handlers.
    
    When intr_handler() returns, the processor "falls through" intr_entry() and starts executing intr_exit(), because these two functions are both written in assembly code, and intr_entry() sits right above intr_exit(), so %EIP+4 naturally leads into intr_entry().
    
    The  `btpagefault` gives:
    #0  _start (argc=<unavailable>, argv=<unavailable>) at ../../lib/user/entry.c:9;

2.3.14
    The problem lies in the setup_stack() function in process.c, which initializes %ESP to PHYS_BASE, discounting the fact that, as the starting value of the user program's stack pointer, there should be return address at %ESP and argc and argv above that. Thus when the user program reaches to (%ESP+8) for argv, it's actually accessing a kernel page, therefore triggering the page fault due to access violation. A solution is to initialize %ESP to PHYS_BASE - 12, accounting for the values that should already be on stack when the user program executes, i.e. argv, argc, and return address.

2.3.15
    First we investigate what the value of %ESP is before the `ret` instruction is executed, i.e. before the context switch. After loading the user program, the %ESP in the interrupt frame is set to 0xc000000. Upon entering the intr_exit() function, the %ESP is 0xc010af58, pointing to the interrupt frame. After `popal`, the %ESP is 0xc010af78; before `ret`, the %ESP is 0x010af94; after `ret`, the %ESP is 0xc0000000. This shows that the `ret` instruction, not `popal`, restores the user %ESP, and that the %ESP initialized by the load() function will be the stack pointer that the user program sees.

    Then we investigate what occurs to the %ESP after the context switch. We disassemble the do-stack-align executable, and see the following assembly codes:
    08048754 <_start>:
        8048754:	sub    $0x1c,%esp
        8048757:	mov    0x24(%esp),%eax
        804875b:	mov    %eax,0x4(%esp)
        804875f:	mov    0x20(%esp),%eax
        8048763:	mov    %eax,(%esp)
        8048766:	call   80480a0 <main>
        804876b:	mov    %eax,(%esp)
        804876e:	call   804a2bc <exit>

    080480a0 <main>:
        80480a0:	mov    %esp,%eax
        80480a2:	and    $0xf,%eax
        80480a5:	ret    
    Note that the entry routine _start() is exactly the same as the one in do-nothing, so %ESP is decremented by 28 bytes before the `call` instruction. %ESP is decremented 4 bytes during the `call` instruction, but afterwards there's no change to %ESP. The do-stack-align test expects the stack pointer there to satisfy %ESP % 16 = 12.

    So here's the full picture: the stack pointer initialized by load() must satisfy the following relationship:
    (%ESP - 28 - 4) % 16 = 12
        (%ESP - 32) % 16 = 12
               %ESP % 16 = 12
                    %ESP = N * 16 + 12
           PHYS_BASE - X = N * 16 + 12
               PHYS_BASE = N * 16 + 12 + X
    where N is a random multiplier, and X is the amount that load() should subtract from PHYS_BASE to produce the initial value of %ESP. Since PHYS_BASE is a page address, it must be stack aligned as well, which means PHYS_BASE can be expressed as Y * 16, giving us:
                 Y * 16 = N * 16 + 12 + X
                 (Y - N) * 16 = 12 + X
    which shows that 12 + X must be a multiple of 16 as well.

    The smallest such X is 4, but the _start() function dereferences the address %ESP + 8, which will still trigger a page fault - %ESP + 8 = PHYS_BASE - 4 + 8 = PHYS_BASE + 4.
    The next such X is 20, and it won't trigger a page fault in _start(), so it can be a solution.

    Note: I still didn't figure out why %ESP % 16 should be 12; in fact, since _start() decrements in multiple of 16 bytes, it should maintain the alignment/mis-alignment in the initial %ESP. If the initial %ESP were to be aligned, it should have a 0 remainder, not 12. It's also unlikely that the 20 Bytes subtracted from PHYS_BASE represents the "int argc" (4 bytes), "char *argv[]" (8 bytes), and "void *return_addr" (8 bytes), because the PINTOS OS only supports 32-bit address (e.g. sizeof(void *) returns 4, not 8). Unless the stack alignment we're talking about here needs to directly agree with the hardware architecture (64-bit machine, so 8 byte address) and not the OS, I don't see a reason why the initial subtraction has to be 20.

    A: The important thing to notice is that:
    1) "int argc", "char *argv[]", and the return address are 4 bytes each, and will take a total of 12 bytes;
    2) the current version of PINTOS did not implement main() argument passing, so if we assume that everything else works the same, the current initial user ESP should sit 12 bytes above the ideal user ESP;
    3) the ideal user ESP should also be aligned on 4-words, which is 16 bytes;

    Combining these three points, we see that:
        current ESP - 12 = ideal ESP
        current ESP - 12 = N * 16
             current ESP = N * 16 + 12
        current ESP % 16 = 12
    
    Note that _start() shifts the initial ESP down by 28 bytes, then it calls main() which shifts the ESP down further by 4 bytes,
    for a total of 32 bytes. So if the initial user ESP is aligned on 4-words, the ESP seen by main() will also be stack-aligned; vice-versa, if main() argument passing is not implemented, then the ESP seen by main() will also be mis-aligned.


2.3.16
    Right before `int x30` software interrupt is executed, the %ESP points to 0x00000001 and 0x000000a2 at the top of the stack;

2.3.17
    The "args" local variable is initialized to the value of the user stack pointer %ESP, and it points to the same values as above, i.e. 0x00000001 and 0x000000a2;

2.3.18
    The "temporary" semaphore is used to awake the original kernel thread that started the user thread, because it has been waiting for the termination of the user thread via the value of the semaphore. Whenever a user process is started, the "temporary" semaphore is untouched and the user thread starts execution, while the kernel thread waits for the user thread to complete by calling sema_down() on the "temporary" semaphore. When the user thread exits, it increments the semaphore, allowing the original kernel thread to be awakened and scheduled;

2.3.19
    The name of the running hread is "main", and its TCB address is 0xc000e000. Indeed, this is the first thread that's created when the kernel started. The two threads that are present are:
        Thread #0: 0xc000e000 {tid = 1, status = THREAD_RUNNING, name = "main", '\000' <repeats 11 times>, stack = 0xc000eeac "\001", priority = 31, allelem = {prev = 0xc0035910 <all_list>, next = 0xc0104020}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}
        
        Thread #1: 0xc0104000 {tid = 2, status = THREAD_BLOCKED, name = "idle", '\000' <repeats 11 times>, stack = 0xc0104f34 "", priority = 0, allelem = {prev = 0xc000e020, next = 0xc0035918 <all_list+8>}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}